\chapter{Introduction}
%\todo[inline,color=blue!10]{Context: what is the bigger scope of the problem you are trying to solve? Try to connect to societal/economical challenges.
%Problem Analysis: Here you present your analysis of the problem situation that your research will address.
%How does this problem manifest itself at your host organisation?
%Also summarises existing scientific insight into the problem.}
\label{ch:introduction}
\todo{Rewrite this part}
Refactoring is used to improve quality related attributes of a codebase (maintainability, performance, etc.) without changing the functionality. There are many methods that have been introduced to help with the process of refactoring \cite{fowler2018refactoring, wake2004refactoring}. However, most of these methods still require manual assessment of where and when to apply them. Because of this, refactoring takes up a signification portion of the development process \cite{lientz1978characteristics, mens2004survey}, or does not happen at all \cite{mens2003refactoring}. For a large part, refactoring requires domain knowledge to do it right. However, there are also refactoring opportunities that are rather trivial and repetitive to execute. In this thesis, we take a look at the challenges and opportunities in automatically refactoring duplicated code, also known as ``code clones''. The main goal is to improve maintainability of the refactored code.

Duplication in source code is often seen as one of the most harmful types of technical debt. \textit{``Clones are problematic for the maintainability of a program, because if the clone is altered at one location to correct an erroneous behaviour, you cannot be sure that this correction is applied to all the cloned code as well. Additionally, the code base size increases unnecessarily and so increases the amount of code to be handled when conducting maintenance work''} \cite{ostberg2014automatically}. Bruntink et al.~\cite{bruntink2005use} show that code clones can contribute up to 25\% of the code size.

In this study, we use refactoring techniques to automatically reduce duplication in software systems. This allows us to obtain before- and after-refactoring snapshots of software systems. We use software maintainability metrics to measure the impact of refactoring clones. This way we can determine better definitions of clones. We also look into what variability we can allow between code fragments to still consider them clones, while still improving maintainability when refactoring these clones. Futhermore, we look into the thresholds that should be used while detecting clones to find clones that should be refactored.

We perform several experiments on a large corpus of open source software to collect statistical data. With these experiments we map the context of clones: where they reside in the codebase and what the relation is between duplicate fragments. We use this information to find appropriate refactoring opportunities for specific clones. We build a script to automatically refactor a subset of these clones.

\section{Problem statement}
In this section we describe the problem we address with this study and the research questions that we answer in order to contribute to solving the problem.

\subsection{The problem}
\todo{How do I formulate this}

\subsection{Research questions}
\todo{Rewrite this part}
Code clones can appear anywhere in the code. Whether a code clone has to be refactored, and how it has to be refactored, is dependent on where it exists in the code (it's context). There are many different contexts in which code clones can occur (in a method, a complete class, in an enumeration, global variables, etc.). Because of this, we first must collect some information regarding in what contexts code clones exist. To do this, we will analyze a set of Java projects for their clones, and generalize their contexts. To come to this information, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 1:}\\How can we group and rank clones based on their harmfulness?
\end{displayquote}
As a result from this research question, we expect a catalog of the different contexts in which clones occur, ordered on the amount of times they occur. On basis of this catalog, we have prioritized the further analysis of the clones. This analysis is to determine a suitable refactoring for the clone type that has been found at the design level. For this, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 2:}\\To what extend can we suggest refactorings of clones at the design level?
\end{displayquote}
As a result, we expect to have proposed refactorings for the most harmful clone patterns. On basis of these design level refactorings we will build a model, which we will proof using Java, that applies the refactorings to corresponding methods. For building this model, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 3:}\\To what extend can we automatically refactor clones?
\end{displayquote}
As a result from this research question, we expect to have a model to be able to refactor the highest priority clones.

\subsection{Research method}
\todo{TODO}

\section{Contributions}
\todo{Rewrite this part}
Our research makes the following contributions:
\begin{enumerate}
	\item We deliver several novel measurements regarding code clones on a large corpus of Java projects.
	\item We deliver a novel clone detection tool that finds refactorable clones in Java.
	\item We deliver a novel clone refactoring tool that suggests refactorings to be applied, and applies these refactorings.
	\item We give further recommendations in how refactoring can be automatically applied to improve maintainability in software projects.
\end{enumerate}

\section{Scope}
\todo{Rewrite this part}
In this research we will look into code clones from a refactoring viewpoint. There are several methods that detect code clones using a similarity score to match pieces of code. This similarity is often based on the amount of tokens that match between two pieces of code. The problem with similarity based clones is that it is hard to assess the impact of merging clones that have different tokens, but what exactly this token is is unknown. Because of this, we will not focus on similarity based clone detection techniques, but rather on exact matches and predefined differences.

It is very disputable whether unit tests apply to the same maintainability metrics that applies to the functional code. Because of that, for this research, unit tests are not taken into scope. The findings of this research may be applicable to those classes, but we will not argue the validity.

\section{Outline}
\todo{Rewrite this part}
In Chapter~\ref{ch:background} we describe the background of this thesis.
Chapter~\ref{ch:research} describes ...
Results are shown in Chapter~\ref{ch:results} and discussed in Chapter~\ref{ch:discussion}. Chapter~\ref{ch:related_work}, contains the work related to this thesis.
Finally, we present our concluding remarks in Chapter~\ref{ch:conclusion} together with future work.
