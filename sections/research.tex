\chapter{Redefining type 1, 2 and type 3 clones}
In the background section we discussed the different types of clones, as defined by Roy et al \cite{roy2007survey}. However, when detecting clones by these definitions, we will detect many clones that are not immediately useful for refactoring. In this chapter, we will discuss the shortcoming of each of the clone types, and propose solutions for them.

\section{Type 1 clones}
Type 1 clones are identical clone fragments except for variations in whitespace and comments. However, when two clone fragments are textually identical, does not yet indicate that they are actually identical. Even when textually equal, method calls can refer to different methods, type declarations can refer to different types and even variables can be of a different type. See figure \ref{fig:type1noclone} for an example of a type 1 clone that is not actually identical. In this figure, you can see how all objects in the supposedly cloned fragment (see the marked fragment) refer to different imports. Because of this, it seems like a clone, but might actually not be. Even the showImage method might refer to a different method (overloaded variants). Many (mainly textual and token-based) clone detectors will flag this as a type 1 clone.

\begin{figure}[H]
	\includegraphics[width=1\textwidth]{img/type-1-no-clone}
	\caption{The marked fragment might seem like a 100\% equal clone, but actually they vary.}
	\label{fig:type1noclone}
\end{figure}

\begin{wrapfigure}{r}{5.5cm}
\caption{A wrapped figure going nicely inside the text.}\label{wrap-fig:1}
\includegraphics[width=5.5cm]{img/type-1-not-cloned}
\end{wrapfigure}

The problem with the clone shown in \ref{fig:type1noclone} is that this could invalidate a refactoring opportunity for such a code fragment (especially when we automate it). Because of that, we recommend redefining type-1 clones for refactoring. We propose to:
\begin{itemize}
  \item \textbf{Compare the equality of the fully qualified method signature for method references.} This way we can validate whether two method references, like method calls, are actually equal. In the method signature, not only the fully qualified identifier of the method should be considered, but also of the type of all its arguments. This way we can be sure that two potentially cloned method references do not point to overloaded variants (in a case that the data type of arguments is overloaded).
  \item \textbf{Compare the equality of the fully qualified identifier for type references.} This way we can be sure that two referenced types are actually equal, and that they are not just two types with the same name.
  \item \textbf{Compare the equality the fully qualified identifier for variable usages.} Two cloned lines might use a variable with the same name, but different types. This might pose serious challenges on refactoring, as the variables might not concern the same object or primitive. To check this, we need to track the declaration of variables and from this infer the fully qualified identifier of its type.
\end{itemize}

\section{Type 2 clones}
Type 2 clones, by definition, allow any change in identifiers, literals, types, layout, and comments. For refactoring purposes, this doesn't always make a lot of sense. If we allow any change in identifiers, literals, and types, we cannot distinguish between different variables, different types and different method calls anymore. This could render two methods that have an entirely different functionality as clones. Merging such clones, if possible at all, might only prove to be harmful.

Because of that, for this research, we have looked into a redefinition of type 2 clones to be able to detect such clones that can and should be merged. Our definition ensures functional similarity by applying the following changes to type 2 clones:

\begin{itemize}
  \item \textbf{Considering types:} The definition of type 2 clones states that types should not be considered. We disagree because types can make a significant change to the meaning of a code segment and thus whether this segment should be considered a clone.
  \item \textbf{Having a distinction between different variables:} By the definition of type 2 clones, any identifiers would not be taken into account. We agree that a difference in identifiers may still result in a harmful clone, but we should still consider the distinction between different variables. For instance, if we call a method like this: \textit{``myMethod(var1, var2)''}, or call this method like this: \textit{``myMethod(var1, var1)''}. Even if the variables have the same type, the distinction between the variables is important to ensure the functionality is the same after merging.
  \item \textbf{Defining a threshold for variability in literals:} By the definition of type 2 clones any literals would not be taken into account. We agree, as when merging the clone (for instance by extracting a method), we can simply turn the literal into a method parameter. However, we would argue that thresholds matter here. How many literals may differ for the segment still to be considered a clone with another segment? We need to define a threshold to be sure that, by merging, we are not replacing a code fragment by a worse maintainable design.
  \item \textbf{Consider method call signatures and define a threshold for variability in method calls:} As type-2 clones allow changes in identifiers, also the names of called methods may vary. However, because of this, completely different methods can be called in cloned fragments as a result. This poses serious challenges on refactoring and makes it more disputable whether such a clone is actually harmful. This is because different method identifiers can describe a completely different functionality. Because of that, we recommend to keep considering the call signatures of cloned methods when they are compared. We can allow variability in the rest of method identifiers by passing the function as a parameter. To limit the amount of parameters required we also recommend defining a threshold for variability in method call expressions, so only a limited number of method calls can vary.

\section{Type 3 clones}
Type 3 clones are even more permissive than type 2 clones, allowing added and removed statements. Thresholds matter a lot here to make sure that not the whole project is detected to be cloned. The main question for this study regarding type 3 clones is: ``how can we merge type 3 clones while improving the design?''.

Clone instances in type 3 clones are almost always different in functionality. As we have to ensure equal functionality after merging the clone, we have to wrap the difference in statements between the clone instances in conditional blocks (either if-statements or switch-statements). We can then pass a variable as to which path should be taken through the code (either a boolean or an enumeration). Such a refactoring would make added statements that are contiguous less harmful for the design then added statements than added statements that are separated by statements that both clone instances have in common.

We also want to argue that statements that are not common between two clone instances, should not count towards the size of the clone (and thus towards the threshold which determines whether the clone will be taken into account). Also, clones should not start and not end with an added statement (as that would be nonsense: such a thing could be done for any clone).

As for the detection of type 3 clones, we think the easiest opportunity to detect these clones is to consider it as a postprocessing step after clone detection. By trying to find short gaps between clones, we can find opportunities to merge clone classes into a single type 3 clone class. The amount of statements that this ``short gap'' can maximally span should be dependent on a threshold value.

\chapter{Clone Detection}
In this chapter, we look into the current state of clone detection research. We held a small survey in which we looked into a set of clone detection tools to determine their applicability for automated refactoring. We then proposed our own tool, CloneRefactor, to be able to detect our definitions of clone types (as defined in the previous chapter).

%\section{Clone detection survey}
%At the beginning of this study, we set out to find a clone detection tool that we could extend to apply automated refactorings. Many tools have been proposed to detect various types of code clones. We have considered a set of tools, selected by the most relevant AST or token based detectors found in a set of surveys \cite{}. However, most of these tools have a vastly different purpose than this thesis. Most of the tools are focused on efficiency and detecting all of the types of clones. Efficiency is lesser of a concern to us, correctness is the most important aspect.

%\subsection{Text- and Token based clone detection}
%Most clone detection tools are either text-based or token-based \cite{}. The main rationale for this is that it makes it easy to support many (programming) languages, it is simpler and it is generally more efficient. This works great for most puposes, but for automated refactoring

%\subsection{Big scale clone detection}
%There are a lot of clone detection tools that focus on detecting large amounts of clones quickly \cite{sajnani2016sourcerercc, svajlenko2016bigcloneeval, kamiya2002ccfinder, livieri2007very}.

\subsection{Our criteria}
To be able to refactor detected clones, it is useful to have the ability to rewrite the AST. We considered a set of clone detection tools for their ability to support the refactoring process automatically. None of the tools we consider seemed completely fit for this purpose, so we decided to implement our own clone detection tool: CloneRefactor\footnote{CloneRefactor (WIP) is available on GitHub: \url{https://github.com/SimonBaars/CloneRefactor}}.

\section{CloneRefactor}
A 2016 survey by Gautam \cite{gautam2016various} focuses more on various techniques for clone detection. For our tool, we decided to combine AST- and Graph-based approaches for clone detection, similar to Scorpio (which is a clone detection tool that's part of TinyPDG: a library for building intraprocedural program dependency graphs for Java programs). We decided to base our tool on the JavaParser library \cite{tomassetti2017javaparser}, as it supports rewriting the AST back to Java code and is useable with all modern Java versions (Java 1-12). We collect each statement and declaration and compare those to find duplicates. This way we build a graph of each statement/declaration linking to each subsequent statement/declaration (horizontally) and linking to each of its duplicates (vertically). This is displayed in figure \ref{fig:clonerefactor}.

\begin{figure}[H]
  \includegraphics[width=1\columnwidth]{img/CodeGraph}
  \caption{Abstract figure of the graph representation built by CloneRefactor}
  \label{fig:clonerefactor}
\end{figure}

\section{Thresholds}
CloneRefactor works on basis of three thresholds for finding clones:
\begin{enumerate}
  \item \textbf{Number of statements/declarations:} The number of statements/declarations that should be equal/similar for it to be considered a clone.
  \item \textbf{Number of tokens:} The number of tokens (excluding whitespace, end-of-line terminators and comments) that should be equal/similar for it to be considered a clone.
  \item \textbf{Number of lines:} The minimum amount of lines (excluding lines that do not contain any tokens, for tokens same exclusions apply) that should be equal/similar for it to be considered a clone.
\end{enumerate}
Of course, if we put any of these thresholds to zero it won't be taken into account anymore, so not all thresholds have to be used at all times. We consider ``number of lines'' to be the least important, as it highly depends on the programmer of the codebase (and we do not want this kind of dependence!). On basis of manual assessment, we have determined that setting the ``number of statements/declarations'' to 6 ensures that most non-harmful clones are filtered out. On the downside, this also filters out some harmful antipatterns, for instance, if a cloned line has many tokens we might want to consider a clone if it spans less than 6 statements (as a cloned line with many tokens is more harmful than one with few).

For the measurements in the next chapter we have chosen to apply the following thresholds:
\begin{itemize}
  \item \textbf{Number of statements/declarations:} 6
  \item \textbf{Number of tokens:} 10
  \item \textbf{Number of lines:} 6
\end{itemize}

\chapter{Code Clone Context}
To be able to refactor code clones, it is very important to consider the context of the clone. We define the following aspects of the clone as its context:
\begin{enumerate}
  \item The relation of clone instances among each other (for example two clone instances in a clone class are part of the same object).
  \item Where a clone instance occurs in the code (for instance: a method-level clone is a clone instance that is (a part of) a single method).
  \item The contents of a clone instance (for instance: the clone instance consists of a one method declaration, a foreach statement, and two variable declarations).
\end{enumerate}
Everything in the context of a clone has a big impact on how it has to be refactored. For this study, we performed measurements on the context of clones in a large corpus of open source projects.

\section{The corpus}
For our measurements we use a large corpus of open source projects \cite{githubCorpus2013}\footnote{The corpus can be downloaded from the following URL: \url{http://groups.inf.ed.ac.uk/cup/javaGithub/java_projects.tar.gz}}. This corpus has been assembled to contain relatively higher quality projects (by filtering by forks). Also, any duplicate projects were removed from this corpus. This results in a variety of Java projects that reflect the quality of average open source Java systems and are useful to perform measurements on.

We then filtered the corpus further to make sure we are not including any test classes or generated classes. Many Java/Maven projects use a structure where they separate the application and its tests in the different folders (``/src/main/java'' and ``/src/test/java'' respectively). Because of this, we chose to only use projects from the corpus which use this structure (and had at least a ``/src/main/java'' folder). To limit the execution time of the script, we also decided to limit the maximum amount of source files in a single project to 1.000 (projects with more source files were not considered, which filtered only 5 extra projects out of the corpus). Of the 14.436 projects in the corpus over 3.848 remained, which is plenty for our purposes. The script to filter the corpus in included in our GitHub repository \footnote{The script we use to filter the corpus: \url{https://github.com/SimonBaars/CloneRefactor/blob/MeasurementsVersion1/src/main/java/com/simonbaars/clonerefactor/scripts/PrepareProjectsFolder.java}}.

Running our clone detection script, CloneRefactor, over this corpus gives the results displayed in table \ref{table:general}.

\begin{table}[H]
  \begin{center}
  \caption{CloneRefactor results for Java projects corpus \cite{githubCorpus2013}.} \label{table:general}
  \bigskip
\begin{tabular}{|l|l|}
\hline
Amount of projects                                                                                      & 3,848      \\ \hline
Amount of lines                                                                                         & 8,284,140  \\ \hline
\begin{tabular}[c]{@{}l@{}}Amount of lines (excluding\\ whitespace, comments, etc.)\end{tabular}        & 8,163,429  \\ \hline
Amount of statements/declarations                                                                       & 6,863,725  \\ \hline
Amount of tokens                                                                                        & 66,964,270 \\ \hline
Amount of lines cloned                                                                                  & 1,341,094  \\ \hline
\begin{tabular}[c]{@{}l@{}}Amount of lines cloned (excluding\\ whitespace, comments, etc.)\end{tabular} & 815,799    \\ \hline
\begin{tabular}[c]{@{}l@{}}Amount of statements/declarations\\ cloned\end{tabular}                      & 747,993    \\ \hline
Amount of tokens cloned                                                                                 & 9,800,819  \\ \hline
Amount of clone classes                                                                                 & 34,367     \\ \hline
\end{tabular}
\end{center}
\end{table}

\section{Relations Between Clone Instances}
When merging code clones in object-oriented languages, it is very important to consider the relation between clone instances. This relation has a big impact on how a clone should be merged, in order to improve the software design in the process.

\subsection{Categorizing Clone Instance Relations}
A paper by Fontana et al \cite{fontana2015duplicated} performs measurements on 50 open source projects on the relation of clone instances to each other. To do this, they first define several categories for the relation between clone instances in object-oriented languages. These categories are as follows:
\begin{enumerate}
  \item \textbf{Same method}: All instances of the clone class are in the same method.
  \item \textbf{Same class}: All instances of the clone class are in the same class.
  \item \textbf{Superclass}: All instances of the clone class are children and parents of each other.
  \item \textbf{Ancestor class}: All instances of the clone class are superclasses except for the direct superclass.
  \item \textbf{Sibling class}: All instances of the clone class have the same parent class.
  \item \textbf{First cousin class}: All instances of the clone class have the same grandparent class.
\item \textbf{Common hierarchy class}: All instances of the clone class belong to the same hierarchy, but do not belong to any of the other categories.
\item \textbf{Same external superclass}: All instances of the clone class have the same superclass, but this superclass is not included in the project but part of a library.
\item \textbf{Unrelated class}: There is at least one instance in the clone class that is not in the same hierarchy.
\end{enumerate}
Please note that no of these categories allow external classes (except for ``same external superclass''). So if two clone instances are related through external classes but do not share a common external superclass, it will be flagged as ``unrelated''. The main reason for this is that it is (often) not possible to refactor to external classes.

The ranking of the previous list of categories also matters as it shows the different levels in which clones were assessed. For instance, if two clone instances of a clone class belong to the ``same method'' category but the third belongs to the ``same class'', we will always choose the item lowest on the list.

\subsection{Our measurements}
We have recreated table 3 of Fontana et al \cite{fontana2015duplicated}, but with the following differences in our setup:
\begin{itemize}
  \item We consider clone classes rather than clone pairs.
\item We use different thresholds regarding when a clone should be considered.
\item We seek by statement/declaration rather than SLOC.
\item We test a broader range of projects (they use a set of 50 relatively large projects, we use a large corpus that was assembled by a machine learning algorithm testing java projects on GitHub for quality, which contains projects of all sizes and with differing code quality).
\end{itemize}

Table \ref{table:relations} contains our results regarding the relations between clone instances.

\begin{table}[H]
  \begin{center}
  \caption{Clone relations} \label{table:relations}
  \bigskip
\begin{tabular}{|l|l|l|} \hline
\textbf{Relation}  & \textbf{Amount} & \textbf{Percentage} \\ \hline
Unrelated          & 13,529           & 39.37               \\ \hline
Same Class          & 8,341            & 24.28               \\ \hline
Sibling            & 5,978            & 17.40               \\ \hline
Same Method         & 2,456            & 7.15                \\ \hline
External Superclass & 2,402            & 6.99                \\ \hline
First Cousin        & 695             & 2.02                \\ \hline
Superclass         & 489             & 1.42                \\ \hline
Common Hierarchy    & 442             & 1.29                \\ \hline
Ancestor           & 28              & 0.08               \\ \hline
\end{tabular}
\end{center}
\end{table}

Comparing it to the results of Fontana et al \cite{fontana2015duplicated}, we find way more unrelated clones. This might be due to the fact that we consider clone classes rather than clone pairs, and mark the clone class ``Unrelated'' even if just one of the clone instances is outside a hierarchy. It could also be that the corpus which we use, as it has generally smaller projects, use more classes from outside the project (which are marked UNRELATED if they do not have a common external superclass). On the second place, we have the ``Same Class'' clones. On the third place come the ``Sibling'' clones.

\section{Clone instance location}
After mapping the relations between individual clones, we looked at the location of individual clone instances. A paper by Lozano et al \cite{lozano2007evaluating} discusses the harmfulness of cloning. In this paper, the author argues that 98\% are produced at method-level. However, this claim is based on a small dataset and based on human copy-paste behavior rather than static code analysis. We validated this claim over the corpus we use. For this, we chose the following categories:
\begin{enumerate}
  \item \textbf{Method/Constructor Level:} A clone instance that does not exceed the boundaries of a single method or constructor (optionally including the declaration of the method or constructor itself).
  \item \textbf{Class Level:} A clone instance in a class, that exceeds the boundaries of a single method or contains something else in the class (like field declarations, other methods, etc.).
  \item \textbf{Interface Level:} A clone that is (a part of) an interface.
  \item \textbf{Enumeration Level:} A clone that is (a part of) an enumeration.
\end{enumerate}

The results for the clone instance locations are shown in table \ref{table:locations}.

\begin{table}[H]
  \begin{center}
  \caption{Clone instance locations} \label{table:locations}
  \bigskip
\begin{tabular}{|l|l|l|}
\hline
\textbf{Location}  & \textbf{Amount}  & \textbf{Percentage} \\ \hline
Method Level       & 19,818           & 57.68               \\ \hline
Class Level        & 13,259           & 38.59               \\ \hline
Constructor Level  & 1,099            & 3.20                \\ \hline
Interface Level    & 110              & 0.32                \\ \hline
Enum Level         & 74               & 0.22                \\ \hline
\end{tabular}
\end{center}
\end{table}

From these results, we can see that the claim of 98\% of clones being produced at method-level is nowhere near correct. In fact, around 58\% of the clones are produced at method-level. About 39\% of clones either span several methods/constructors or contain something like a field declaration. Another 3\% of the clones are found in constructors. The amount of clones found in interfaces and enumerations is very low.

\section{Clone instance contents}
Finally, we looked at the contents of individual clone instances: what kind of declarations and statements do they span. We selected the following categories to be relevant for refactoring:
\begin{enumerate}
  \item \textbf{Full Method/Class/Interface/Enumeration:} A clone that spans a full class, method, constructor, interface or enumeration, including its declaration.
  \item \textbf{Partial Method/Constructor:} A clone that spans a method partially, optionally including its declaration.
  \item \textbf{Several Methods:} A clone that spans over two or more methods, either fully or partially, but does not span anything but methods (so not fields or anything in between).
  \item \textbf{Only Fields:} A clone that spans only global variables.
  \item \textbf{Includes Fields/Constructor:} A clone that spans a combination of fields and other things, like methods.
  \item \textbf{Method/Class/Interface/Enumeration Declaration:} A clone that contains the declaration (usually the first line) of a class, method, interface or enumeration.
  \item \textbf{Other:} Anything that does not match with above-stated categories.
\end{enumerate}

The results for these categories are displayed in table \ref{table:contents}.

\begin{table}[H]
  \begin{center}
  \caption{Clone instance contents} \label{table:contents}
  \bigskip
\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Contents}                                                        & \textbf{Amount} & \textbf{Percentage} \\ \hline
  Partial Method                                                           & 19,264          & 56.07               \\ \hline
  Several Methods                                                          & 9,076           & 26.41               \\ \hline
  Includes Constructor                                                     & 1,528           & 4.45                \\ \hline
  Includes Field                                                           & 1,149           & 3.34                \\ \hline
  Partial Constructor                                                      & 1,098           & 3.20                \\ \hline
  Only Fields                                                              & 565             & 1.64                \\ \hline
  Full Method                                                              & 554             & 1.61                \\ \hline
  \begin{tabular}[c]{@{}l@{}}Includes Class\\ Declaration\end{tabular}     & 445             & 1.30                \\ \hline
  Other                                                                    & 369             & 1.07                \\ \hline
  Full Class                                                               & 192             & 0.56                \\ \hline
  \begin{tabular}[c]{@{}l@{}}Includes Enum\\ Constant\end{tabular}         & 52              & 0.15                \\ \hline
  \begin{tabular}[c]{@{}l@{}}Includes Enum\\ Declaration\end{tabular}      & 47              & 0.14                \\ \hline
  \begin{tabular}[c]{@{}l@{}}Includes Interface\\ Declaration\end{tabular} & 10              & 0.03                \\ \hline
  Full Interface                                                           & 6               & 0.02                \\ \hline
  Full Enumeration                                                         & 4               & 0.01                \\ \hline
\end{tabular}
\end{center}
\end{table}

Unsurprisingly, most clones span a part of a method. Just 1.6\% of the methods are cloned fully. More than a quarter of the clones spans over several methods, which is surprising. Simply extracting methods won't work in a case where a clone spans over several methods. About 4.5\% of clones include a constructor. About 3.3\% of clones include a global variable defined in a class.

\chapter{Merging duplicate code through refactoring}
Now we have mapped the contexts in which clones occur, we can start looking at refactoring opportunities. Regarding refactoring, we separate clones in two categories: easy and difficult refactoring opportunities. Easy refactoring opportunities are clones that can easily be automatically refactored. Examples of these opportunities are fully cloned methods or a set of fully cloned statements. According to the relation between the clone instances, we can propose a refactoring automatically.

However, not always can a clone easily be merged. Sometimes a clone spans a statement partially (like a for-loop of which only it's declaration and a part of the body is cloned). Merging the clones can be harder in such instances. Also, the cloned code can contain a complex control structure, like labels, return, break, continue, etc. In such instances, more conditions apply to be able to conduct a refactoring, if advisable at all.

The most trivial way to merge a clone is through method extraction. However, method extraction is not always possible. For instance, if a part of a subtree (in a programs' AST) is matched as a clone. Because of this, we chose to measure what percentage of ``Partial Method'' clones are refactorable using method extraction. Our results are displayed in table \ref{table:refactorability}.

\begin{table}[H]
  \begin{center}
  \caption{Clone instance contents} \label{table:refactorability}
  \bigskip
\begin{tabular}{|l|l|l|}
\hline
\textbf{Refactorability}        & \textbf{Amount} & \textbf{Percentage} \\ \hline
\begin{tabular}[c]{@{}l@{}}Cannot directly\\be extracted\end{tabular}    & 10,990           & 41.91               \\ \hline
\begin{tabular}[c]{@{}l@{}}Is not a\\partial method\end{tabular} & 9,444            & 36.01               \\ \hline
\begin{tabular}[c]{@{}l@{}}Can be\\extracted\end{tabular}                & 5,791            & 22.08               \\ \hline

\end{tabular}
\end{center}
\end{table}

From this table, we can see that approximately 22 percent of the clones can be refactored through method extraction. For the other clones, we must first build a catalog of appropriate refactorings.
