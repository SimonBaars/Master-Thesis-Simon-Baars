\chapter*{Abstract}
%\todo[inline,color=blue!10]{This should be done when most of the rest of the document is finished. Be concise, introduce context, problem, known approaches, your solution, your findings.}
Duplication in source code is often seen as one of the most harmful types of technical debt as it increases the size of the codebase and creates implicit dependencies between fragments of code. To remove such anti-patterns, the codebase should be refactored. Many tools aid in the detection process of such duplication problems but fail to determine whether refactoring a duplicate fragment would improve the maintainability.

We address this shortcoming by combining automated refactoring and maintainability metrics to measure the impact of refactoring code clones. We propose definitions of clones that can be automatically refactored. We then propose a tool to detect such clones, analyze their context and automatically refactor a subset of them. We use a set of established metrics to determine the impact of the applied refactorings on the maintainability of the system. Based on these results, one could decide which clones improve system design and thus should be refactored. We evaluate our approach over a large corpus of open source Java projects.

We analyze the overhead of applying a refactoring in terms of four factors: the size of the clone, the relation between the code fragments in a clone, whether clone fragments create, modify or return data and the amount of external data that cloned fragments use. We find that the size of similar fragments in a clone is the biggest influencing factor: the majority of duplicates with a total volume of 68 or more tokens improve maintainability when refactored. The amount of external data that needs to be passed to the merged location of the duplicate is the other important factor: the refactored method should not have more than 1 parameter.
