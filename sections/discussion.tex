\chapter{Discussion}
\label{ch:discussion}
%Interpretations: what do the results mean?
%Implications: why do the results matter?
%Limitations: what canâ€™t the results tell us?
%Recommendations: what practical actions or scientific studies should follow?

In this chapter, we discuss the results of our research and experiments.

\section{Clone Type Definitions}
In this study, we proposed a set of clone type definitions for which a refactoring opportunity is known.
% TODO: Sander - is known is beetje gek
% TODO: Sander - zou ook uitleggen waarom we nieuwe definities nodig hadden
We based these clone type definitions on the clone type definitions that are commonly used in literature. The design of these clone type definitions entails some decisions that have a large impact on the clones we considered for refactoring in this study. In this section we discuss our clone type definitions as proposed in Section~\ref{sec:rtypes}.

\subsection{Type 2R clones}
With type 2R clones we allow variability in some identifiers and literals such that the code can and should still be refactored. For type 2R clones we chose a set of expressions in which we allow variability and proposed a recommended refactoring strategy. We think however that type 2R could still use a lot of improvement to find more duplication patterns that can be refactored.

One method we think can be used to find more refactoring opportunities is to allow variability in expressions that have/return the same type. If expressions have/return the same type, they can be extracted to a parameter and the corresponding expression can be passed as a parameter. An example of this is displayed in Figure~\ref{fig:samereturn}. The only thing to watch out for is method that has side effects. Because methods may be executed in another point during execution, this might affect the functionality of the code.
% TODO: Sander - how would you try to solve this?

\begin{figure}[H]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{javacode}
// Original
public void doStuff(){
  int numbers = 456;
|\highlightYellow|  doA(getTitle());
|\highlightYellow|  doB(123);
  doC();
|\highlightYellow|  doA("456");
|\highlightYellow|  doB(numbers);
}

public String getTitle(){
  return "123";
}
\end{javacode}}
\colchunk[2]{
\begin{javacode}
// Refactored
public void doStuff(){
  int numbers = 456;
|\highlightYellow|  doAandB(getTitle(), 123);
  doC();
|\highlightYellow|  doAandB("456", numbers);
}

public void doAandB(String var1, int var2){
  doA(var1);
  doB(var2);
}

public String getTitle(){
  return "123";
}
\end{javacode}}
\end{parcolumns}
\caption{Refactoring different expressions that have the same return type.}
\label{fig:samereturn}
\end{figure}

\section{Clone Context Analysis}
In Section~\ref{chap:contextsetup} we introduced the categories we defined for mapping the context of clones. In this section, we discuss this together with the related experiments.

\section{CloneRefactor}
In this section we discuss our decisions for the design of our CloneRefactor tool.

\subsection{Clone Detection}
For CloneRefactor we chose to design a novel method of detecting clones, rather than using an existing clone detection technique or tool. Our rationale is as follows:
\begin{itemize}
  \item We perform comprehensive analysis on the source code which requires us to use an AST-based clone detection method.
  \item We perform dependency graph analysis, which requires us to resolve symbols in the source code.
  \item None of the existing clone detection methods implement all criteria required to build such a system.
\end{itemize}
By building a graph that maps relations between nodes in the AST, we can find clones in an efficient manner, allowing to perform a comprehensive analysis of large systems. This method has worked well for our purposes.

The main limitation we encountered is the memory required to build the clone graph. As we load the entire graph into memory before starting the clone detection procedure, this can cause issues on systems with low available memory. For a system consisting of 1.000.000 nodes, the clone graph requires about 4GB of RAM. For our corpus, there were no larger systems, so this was not a big issue. However, for industry projects our tool might require optimization.

\subsection{Context Analysis}
In this study we identified categories for three properties of clones: relation, location and contents. %Mapping the location and contents was mainly to find out what the best method of refactoring is to refactor most clones.
We chose a set of relations that indicate different refactoring opportunities. However, as our CloneRefactor tool only analyses Java source code, we we biased towards categories that are often found in Java source code. For other languages, other categories might be valuable to analyze to find suitable categories for that programming language.

\subsection{Refactoring}
In this section, we discuss our implementation decisions to refactor source code using CloneRefactor and measure its impact.

\subsubsection{Refactorability} \label{sec:discussrefactorability}
In Section~\ref{sec:refactorability} we introduced catagories to determine the refactorability of clones through method extraction. We excluded categories that could not not be directly refactored through method extraction. However, with a few transformations or further considerations it might be possible to make these clones refactorable. In this section we will highlight a few of these categories which we believe to be refactorable through method extraction with more effort.

\subsubsection{Partial block} \label{sec:partialblockdiscussion}
We did not consider clones for refactoring that span a part of a block. Although it is indeed not possible to refactor such clones, there are possibilities to make such clones refactorable. For instance, if the programming language supports lambda expressions, we can move the difference of statements in the block in a lambda expression \cite{tsantalis2017clone}. Figure \ref{fig:partialblockrefactoring} shows an example of such a refactoring opportunity.

\begin{figure}[H]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{javacode}
// Original
public void doStuff(){
|\highlightYellow|  for(int i = 0; i<5; i++) { //Only the declaration of this for loop is cloned, but the loop body is not.
    System.out.println("hello!");
  }
|\highlightYellow|  for(int i = 0; i<5; i++) {
    CoreController.activateCore(i);
  }
}
\end{javacode}}
\colchunk[2]{
\begin{javacode}
// Refactored
public void doStuff(){
|\highlightYellow|  doFiveTimes(() -> System.out.println("hello!"));
|\highlightYellow|  doFiveTimes(() -> CoreController.activateCore(i));
}

public void doFiveTimes(Runnable runnable){
  for(int i = 0; i<5; i++) { //Only the declaration of this for loop is cloned, but the loop body is not.
    runnable.run();
  }
}
\end{javacode}}
\end{parcolumns}
\caption{Refactoring a method that is obstructed by a complex control flow.}
\label{fig:partialblockrefactoring}
\end{figure}

\subsubsection{Complex control flow}
Break, continue and return statements can obstruct the possibility of performing method extraction. However, with some extra transformations, method extraction will still be possible in such cases. Figure \ref{fig:complexcontrolflowrefactoring} shows such a transformation. We can wrap the newly extracted method in a conditional to indicate whether the ``control flow modifying statement'' should be executed. In other cases, other methods might apply to refactor such clones.

\begin{figure}[H]
\begin{parcolumns}{2}
\colchunk[1]{
\begin{javacode}
// Original
public boolean doStuff(){
|\highlightYellow|  if(doA());
|\highlightYellow|    return false;
|\highlightYellow|  doB();
  doC();
|\highlightYellow|  if(doA());
|\highlightYellow|    return false;
|\highlightYellow|  doB();
  return true;
}
\end{javacode}}
\colchunk[2]{
\begin{javacode}
// Refactored
public boolean doStuff(){
|\highlightYellow|  if(!doAandB())
|\highlightYellow|    return false;
  doC();
|\highlightYellow|  return doAandB();
}

public boolean doAandB(){
  if(doA())
    return false;
  doB();
  return true;
}
\end{javacode}}
\end{parcolumns}
\caption{Refactoring a method that is obstructed by a complex control flow.}
\label{fig:complexcontrolflowrefactoring}
\end{figure}

\subsubsection{Metrics}
For this study we chose to focus on a set of four metrics to measure maintainability: method size, duplication, method parameters and cyclomatic complexity. These metrics give an indication of the impact of the refactoring, but do not give a complete overview. There are many more metrics that could be considered to measure the maintainability impact on the system. An example of such a metric is ``coupling'', which focuses on the amount of incoming calls into a method or class and what modules these calls come from. This metric is also influenced by the transformations we applied and might deliver valuable insights in the quality of the refactoring.

In general, considering other metrics can result in a more reliable measure of the increase or decrease of maintainability after applying a specific refactoring.

\section{Results}
In this section, we discuss the results of our experiments.

\subsection{Clone Types}
In this section, we discuss the differences between clone types 1-3 and 1R-3R. We see that the difference between T1R and T1 in terms of found clones is small (11\%). This implies that most often textually equal code is also functionally equal. The difference between T2R and T2 is bigger (35\%). Upon manual inspection we found that the main reason for this is that T2R does not allow any variability in types, wheareas T2 allows any variability in types.

Regarding performance (Figure~\ref{fig:performance}, there is a notable difference between the refactoring-oriented clone types and the literature clone types. Type 1R-3R take about 6 times longer to detect than type 1-3. The main reason for this is type resolution: finding the fully qualified identifiers of type-, variable- and method-references.

In Figure~\ref{fig:t2rgraph} we show the increase of cloned nodes for a higher variability between clone instances. This graph is logaritmic: as the variability increases, the increase in nodes decreases. This implies that semantical equality increases the chances that tokens are equal.

In Figure~\ref{fig:t3rgraph} we show the increase of cloned nodes for higher type 3R gap sizes. The line denoting the number of clone classes seems a bit exponential whereas the line denoting cloned nodes is mostly linear. This makes sense regarding the nature of the threshold. As we get into higher gap size percentages, fewer clones merge (thus the decrease in amount of clone classes merging). However, at these higher gap size percentages the gaps contains more nodes (thus the amount of cloned nodes being linear).

\subsection{Clone Context}
Regarding clone context, our results indicate that most clones (37\%) are in a common class. This is favorable for refactoring because the extracted method does not have to be moved after extraction. 24\% of clones are in a common hierarchy. These refactorings are also often favorable. Another 24\% of clones are unrelated, which is often unfavorable because it often requires a more comprehensive refactoring. 15\% of clones are in an interface.

Regarding clone contents, 74\% of clones span part of a method body (77\% if we include constructors). 8\% of clones span several methods, which often require refactorings on a more architectural level. 6\% of clones span only global variables, requiring an abstraction to encapsulate these data declarations. Only 4\% of clones span a full declaration (method, class, constructor, etc.).

\subsection{Extract Method}
28\% of clones can be refactored using the ``Extract Method'' refactoring technique (50\% if we limit our searching scope to method bodies). About 25\% of clones do not span part of a method, because of which they cannot be refactored. Many clones (23\%) do not have a statement as top-level AST-Node. Upon manual inspection, we noticed that the main reason for this is clones in anonymous functions or anonymous classes. About 15\% of clones span only part of an AST-Node.

\subsection{Refactoring}
In Fig.~\ref{fig:maintainabilityscore} we see an increase in maintainability for refactoring larger clone classes. The tipping point, between a better maintainable refactoring and a worse maintainable refactoring, seems to lie at a token volume of 63 tokens. There are fewer large clones than small clones, resulting in a very limited statistical significance on our corpus when considering clones larger than 100 tokens.

In Table~\ref{tab:relationref} we see the results regarding refactorings that are applied to clones with diverse relations. We see that most refactored clones are in a common class, over 54\%. This is significantly more than the percentage of clones in the common class relation as reported in Table~\ref{tab:relation}. Meanwhile, the number of refactored unrelated clones is smaller than the number reported in Table~\ref{tab:relation} (24\% -> 18\%). The main reason for this is that refactoring unrelated clones can change the relation of other clones in the same system. If we create a superclass abstraction to refactor an unrelated clone, other clones in those classes that were previously unrelated might become related.

The maintainability scores displayed in Table~\ref{tab:relationref} show that the most favorable clones to refactor are clones with a sibling relation. The most unfavorable is to refactor clones to interfaces. However, the differences in maintainability in this table are generally small; according to our data relations have a minor impact on the maintainability of clones.

Regarding the return type of refactored clones, we see in Table~\ref{tab:return} that this has no major impact on maintainability. A method call to the extracted method that is directly returned and no return type extracted methods are slightly more favorable than the others. We think the main reason that the ``Return'' category is on top is that when a variable is declared at the end of the cloned fragment, CloneRefactor directly returns its value and removes the declaration. This decreases the volume slightly.

A higher number of parameters directly influences the corresponding metric. Because of this, we see in Fig.~\ref{fig:arguments} that more parameters negatively influence maintainability. Not only the number of parameters metric is negatively influenced, but more method parameters also increase volume for the extracted method and each of the calls to it. Because of that, we see that trend of the graph in Fig.~\ref{fig:arguments} decreases relatively rapidly.
