\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{color}
\usepackage{listings}
\usepackage{parcolumns}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  numbers = left,
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\definecolor{lightyellow}{HTML}{fffdcc}
\definecolor{doublelightyellow}{HTML}{fffa9c}
\definecolor{lightgreen}{HTML}{dcffd4}
\definecolor{lightblue}{HTML}{e0ffff}
\definecolor{lightred}{HTML}{ffe0e0}
\definecolor{lightpink}{HTML}{ffe0ff}
\definecolor{lightorange}{HTML}{ffede0}
\definecolor{lightpurple}{HTML}{f0e0ff}
\newcommand{\highlightYellow}{\makebox[0pt][l]{\color{lightyellow}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightGreen}{\makebox[0pt][l]{\color{lightgreen}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightBlue}{\makebox[0pt][l]{\color{lightblue}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightRed}{\makebox[0pt][l]{\color{lightred}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightPink}{\makebox[0pt][l]{\color{lightpink}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightOrange}{\makebox[0pt][l]{\color{lightorange}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightPurple}{\makebox[0pt][l]{\color{lightpurple}\rule[-4pt]{1\linewidth}{14pt}}}
\newcommand{\highlightDarkyellow}{\makebox[0pt][l]{\color{doublelightyellow}\rule[-4pt]{1\linewidth}{14pt}}}

\lstnewenvironment{javacode}[1][]{\lstset{language=Java,escapechar=|,tabsize=2, breaklines=true, xleftmargin=.25in, keywordstyle=\color{pblue},basicstyle=\small,#1}}{}


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Improving Software Maintainability through Automated Refactoring of Code Clones}

\author{\IEEEauthorblockN{1\textsuperscript{st} Simon Baars}
\IEEEauthorblockA{%\textit{Software Engineering} \\
\textit{University of Amsterdam}\\
Amsterdam, the Netherlands \\
simon.mailadres@gmail.com}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Ana Oprescu}
\IEEEauthorblockA{%\textit{dept. name of organization (of Aff.)} \\
\textit{University of Amsterdam}\\
Amsterdam, the Netherlands \\
ana.oprescu@uva.nl}
}

\maketitle

\begin{abstract}
Duplication in source code is often seen as one of the most harmful types of technical debt, because it increases the size of the codebase and creates implicit dependencies between fragments of code. To remove such antipatterns, a developer should refactor the codebase. There are many tools that assist in this process. The thresholds and prioritization of the clones detected by such tools can be improved by considering the maintainability of the codebase after a detected clone would be refactored.

In this study, we define clones that can be refactored. We propose a tool to detect such clones and automatically refactor a subset of them. We use a set of metrics to determine the impact of the applied refactorings to the maintainability of the systems. These metrics are system size, cyclomatic complexity, duplication and number of method parameters. On basis of these results, we decide which clones improve system design and thus should be refactored. %We identified a set of four factors that influence the maintainability impact of clones. The first is the size of the clone. The second is the relation between the code fragments in a clone. The third is whether the clone fragments create, modify or return data. The fourth is the amount of data that cloned fragments use. By using these four factors, we can suggest only clones that will improve maintainability when refactored and prioritize them accordingly.

Given these maintainability influencing factors and their effect on the source code, we measure their impact over a large corpus of open source Java projects. This results in a set of thresholds by which clones can be found that should be refactored to improve system maintainability.
\end{abstract}

\begin{IEEEkeywords}
code clones, refactoring, static code analysis, object-oriented programming
\end{IEEEkeywords}

\section{Introduction}
Duplication in source code is often seen as one of the most harmful types of technical debt, because it increases the size of the codebase and create implicit dependencies between fragments of code \cite{ostberg2014automatically}. Bruntink et al.~\cite{bruntink2005use} show that code clones can contribute up to 25\% of the code size.

Current code clone detection detection techniques base their thresholds and prioritization on a limited set of metrics. Often, clone detection techniques are limited to measuring the size of clones to determine whether they should be considered. Because of this, the output of clone detection tools is often of limited assistance to the developer in the refactoring process.

In this study, we define a technique to detect clones such that they can be refactored. We evaluate the context of clones to determine refactoring techniques are required to refactor clones in a specific context. We propose a tool for the automated refactoring of a subset of the detected clones, by extracting a new method out of duplicated code.

\section{Background}
This study researches an intersection of code clone and refactoring research. In this background section, we will explain the required background knowledge for terms used throughout this study.

\subsection{Code clone terminology}
In this study we use two concepts used to argue about code clones \cite{roy2007survey}:
\textbf{Clone instance}: A single cloned fragment.
\textbf{Clone class}: A set of similar clone instances.

%\subsection{Code clone definitions} Optional -> may do this if it adds something to the story
%Quick overview of clone type definitions

\subsection{Refactoring techniques}
In this section, we describe refactoring techniques that are relevant to refactoring code clones.

\subsubsection{Extract Method}
The most used technique to refactor duplicate code is ``Extract Method'' \cite{fowler2018refactoring}, which can be applied on code inside the body of a method. Several studies have already concluded that most duplication in source code is found in the body of methods \cite{lozano2007evaluating, white2016deep, bergman2004ethnographic}. The ``Extract Method'' technique moves functionality in method bodies to a new method. To reduce duplication, we extract the contents of a single clone instance to a new method and replace all clone instances by a call to this method.

\subsubsection{Move Method}
Often, ``Extract Method'' alone is not enough to refactor clones. This is because the extracted method has to be moved to a location that is accessible by all clone instances. To do this, we apply the ``Move Method'' refactoring technique \cite{fowler2018refactoring}. In object-oriented programming languages, we often move methods up in the inheritance structure of classes, also called ``Pull Up Method'' \cite{fowler2018refactoring}.

\section{Defining refactorable clones}
% Instead of defining clone types, I just define how we can ensure that clones can be refactored. I do not plan to differentiate between T1R, T2R and T3R here, because I think it makes the paper confusing.
% To be honest, I'm not even sure how relevant it is to name the literature clone types. Maybe not focus on their shortcomings, but just start from the core (sourcecode) and define how we can get to refactorable clones.
In literature, several clone type definitions have been used to argue about duplication in source code \cite{roy2007survey}. In this section, we discuss how we can define clones such that they can be refactored without side effects on the source code.

\subsection{Ensuring Equality}
% Explain type 1, why it is not always refactorable, solution
Most modern clone detection tools detect clones by comparing the code textually together with the ommission of certain tokens \cite{roy2009comparison, svajlenko2014evaluating}. Clones detected by such means may not always be suitable for refactoring, because textua comparison fails to take into account the context of certain symbols in the code. Information that gets lost in textual comparison is the referenced declaration for type, variable and method references. Equally named type, variable and method references may refer to different declarations with a different implementation. Such clones can be harder to refactor, if benificial at all.

To detect clones that can be refactored, we propose to:
\begin{itemize}
  \item Compare variable references not only by their name, but also by their type.
  \item Compare referenced types by their fully qualified identifier (FQI). The FQI of a type reference describes the full path to where it is declared.
  \item Compare method references by their fully qualified signature (FQS). The FQS of a method reference describes the full path to where it is declared, plus the FQI of each of its parameters.
\end{itemize}

% Do we want an example here?

\subsection{Allowing variability in a controlled set of expressions}
%Explain type 2, why it is not always refactorable, solution
Often, duplication fragments in source code do not match exactly \cite{kodhai2013method}. Often when developers duplicate fragments of code, they modify the duplicated block to fit its new location and purpose. To detect duplicate fragments with minor variance, we looked into in what expressions we can allow variability while still being refactorable.

We define the following expressions as refactorable when varied:
\begin{itemize}
  \item \textbf{Literals}: Only if all varying literals in a clone class have the same type.
  \item \textbf{Variables}: Only if all varying variables in a clone class have the same type.
  \item \textbf{Method references}: Only if the return value of referenced method match (or are not used).
\end{itemize}
Often when allowing such variance, tradeoffs come into play. For instance, variance in literals may require the introduction of a parameter, increasing the required effort to comprehend the code.

\begin{figure}
\begin{parcolumns}{2}
\colchunk[1]{
\begin{javacode}
// Original
void doABC(){
	doA();
	doB("abc");
	doC();
}

void doDEF(){
  doA();
  doB("def");
  doC();
}
\end{javacode}}
\colchunk[2]{
\begin{javacode}
// Refactored
void doABC(){
	do("abc");
}

void doDEF(){
	do(s, "def");
}

void doThis(String s){
  doA();
  doB(s);
  doC();
}
\end{javacode}}
\end{parcolumns}
\caption{Literal variability refactored.}
\label{fig:type2literal}
\end{figure}

\subsection{Gapped clones}
Explain type 3, why it is not always refactorable, solution

\section{CloneRefactor}
% NEED TO EXPLAIN WHY DO CURRENT DETECTION TOOLS NOT SUFFICE
The tool: Detect Clones, Map Context, Refactor.

\subsection{Clone Detection}
Detecting refactorable clones, (clone graph?? do I want to explain my exact methods?)

\subsection{Context Mapping}
\subsubsection{Relation}
The rationale for our categories regarding clone relations.

\subsubsection{Location}
The rationale for our categories regarding clone locations.

\subsubsection{Contents}
The rationale for our categories regarding clone contents.

\subsection{Refactoring}
\subsubsection{Extract Method}
Show my categories to show what clones can be dealt with by method extraction.

\subsubsection{AST Transformation}
Explain what AST transformations I do to apply the refactorings.

\subsubsection{The cyclic nature of refactoring}
Explain how refactoring code clones might open up new refactoring opportunities. We refactor a project until there are no more open refactoring opportunities.

\section{Results}

\subsection{Clone context}
How many clones are there in certain contexts? Experiments for relation, location and context.

\subsection{Clone refactorability}
To what extent can found clones be refactored through method extraction, without requiring additional transformations.

\subsection{Thresholds}
I think the ultimate goal with this thesis is to do experiments with different clone thresholds. Which thresholds give clones that we should refactor? For this, we will measure the maintainability of the refactored source code over different thresholds. These thresholds range from minimum clone size, variability and gap size.

\section{Discussion}
\subsection{Clone Definitions}

\subsection{CloneRefactor}

\subsection{Experimental setup}

\section{Conclusion}

\section*{Acknowledgment}
We would like to thank the Software Improvement Group for their continuous support in this project. In particular, we would like to thank Xander Schrijen for his invaluable input in this research. Furthermore, we would like to thank Sander Meester for his proofreading efforts and feedback.

\section*{References}


\end{document}
