\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{float}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Improving Software Maintainability through Automated Refactoring of Code Clones}

\author{\IEEEauthorblockN{1\textsuperscript{st} Simon Baars}
\IEEEauthorblockA{%\textit{Software Engineering} \\
\textit{University of Amsterdam}\\
Amsterdam, the Netherlands \\
simon.mailadres@gmail.com}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Ana Oprescu}
\IEEEauthorblockA{%\textit{dept. name of organization (of Aff.)} \\
\textit{University of Amsterdam}\\
Amsterdam, the Netherlands \\
ana.oprescu@uva.nl}
}

\maketitle

\begin{abstract}
Duplication in source code is often seen as one of the most harmful types of technical debt, because it increases the size of the codebase and creates implicit dependencies between fragments of code. To remove such antipatterns, a developer should refactor the codebase. There are many tools that assist in this process. The thresholds and prioritization of the clones detected by such tools can be improved by considering the maintainability of the codebase after a detected clone would be refactored.

In this study, we define clones that can be refactored. We propose a tool to detect such clones and automatically refactor a subset of them. We use a set of metrics to determine the impact of the applied refactorings to the maintainability of the systems. These metrics are system size, cyclomatic complexity, duplication and number of method parameters. On basis of these results, we decide which clones improve system design and thus should be refactored. %We identified a set of four factors that influence the maintainability impact of clones. The first is the size of the clone. The second is the relation between the code fragments in a clone. The third is whether the clone fragments create, modify or return data. The fourth is the amount of data that cloned fragments use. By using these four factors, we can suggest only clones that will improve maintainability when refactored and prioritize them accordingly.

Given these maintainability influencing factors and their effect on the source code, we measure their impact over a large corpus of open source Java projects. This results in a set of thresholds by which clones can be found that should be refactored to improve system maintainability.
\end{abstract}

\begin{IEEEkeywords}
code clones, refactoring, static code analysis, object-oriented programming
\end{IEEEkeywords}

\section{Introduction}
Duplication in source code is often seen as one of the most harmful types of technical debt, because it increases the size of the codebase and create implicit dependencies between fragments of code \cite{ostberg2014automatically}. Bruntink et al.~\cite{bruntink2005use} show that code clones can contribute up to 25\% of the code size.

Current code clone detection detection techniques base their thresholds and prioritization on a limited set of metrics. Often, clone detection techniques are limited to measuring the size of clones to determine whether they should be considered. Because of this, the output of clone detection tools is often of limited assistance to the developer in the refactoring process.

In this study, we define a technique to detect clones such that they can be refactored. We evaluate the context of clones to determine refactoring techniques are required to refactor clones in a specific context. We propose a tool for the automated refactoring of a subset of the detected clones, by extracting a new method out of duplicated code.

\section{Background}
This study researches an intersection of code clone and refactoring research. In this background section, we will explain the required background knowledge for terms used throughout this study.

\subsection{Code clone terminology}
In this study we use two concepts used to argue about code clones \cite{roy2007survey}:
\textbf{Clone instance}: A single cloned fragment.
\textbf{Clone class}: A set of similar clone instances.

%\subsection{Code clone definitions} Optional -> may do this if it adds something to the story
%Quick overview of clone type definitions

\subsection{Refactoring techniques}
In this section, we describe refactoring techniques that are relevant to refactoring code clones.

\subsubsection{Extract Method}
The most used technique to refactor duplicate code is ``Extract Method'' \cite{fowler2018refactoring}, which can be applied on code inside the body of a method. Several studies have already concluded that most duplication in source code is found in the body of methods \cite{lozano2007evaluating, white2016deep, bergman2004ethnographic}. The ``Extract Method'' technique moves functionality in method bodies to a new method. To reduce duplication, we extract the contents of a single clone instance to a new method and replace all clone instances by a call to this method.

\subsubsection{Move Method}
Often, ``Extract Method'' alone is not enough to refactor clones. This is because the extracted method has to be moved to a location that is accessible by all clone instances. To do this, we apply the ``Move Method'' refactoring technique \cite{fowler2018refactoring}. In object-oriented programming languages, we often move methods up in the inheritance structure of classes, also called ``Pull Up Method'' \cite{fowler2018refactoring}.

\section{Defining refactorable clones}
% Instead of defining clone types, I just define how we can ensure that clones can be refactored. I do not plan to differentiate between T1R, T2R and T3R here, because I think it makes the paper confusing.
% To be honest, I'm not even sure how relevant it is to name the literature clone types. Maybe not focus on their shortcomings, but just start from the core (sourcecode) and define how we can get to refactorable clones.
In literature, several clone type definitions have been used to argue about duplication in source code \cite{roy2007survey}. In this section, we discuss how we can define clones such that they can be refactored without side effects on the source code.

\subsection{Ensuring Equality}
% Explain type 1, why it is not always refactorable, solution
Most modern clone detection tools detect clones by comparing the code textually together with the ommission of certain tokens \cite{roy2009comparison, svajlenko2014evaluating}. Clones detected by such means may not always be suitable for refactoring, because textua comparison fails to take into account the context of certain symbols in the code. Information that gets lost in textual comparison is the referenced declaration for type, variable and method references. Equally named type, variable and method references may refer to different declarations with a different implementation. Such clones can be harder to refactor, if benificial at all.

To detect clones that can be refactored, we propose to:
\begin{itemize}
  \item Compare variable references not only by their name, but also by their type.
  \item Compare referenced types by their fully qualified identifier (FQI). The FQI of a type reference describes the full path to where it is declared.
  \item Compare method references by their fully qualified signature (FQS). The FQS of a method reference describes the full path to where it is declared, plus the FQI of each of its parameters.
\end{itemize}

% Do we want an example here?

\subsection{Allowing variability in a controlled set of expressions} \label{sec:t2r}
%Explain type 2, why it is not always refactorable, solution
Often, duplication fragments in source code do not match exactly \cite{kodhai2013method}. Often when developers duplicate fragments of code, they modify the duplicated block to fit its new location and purpose. To detect duplicate fragments with minor variance, we looked into in what expressions we can allow variability while still being refactorable.

We define the following expressions as refactorable when varied:
\begin{itemize}
  \item \textbf{Literals}: Only if all varying literals in a clone class have the same type.
  \item \textbf{Variables}: Only if all varying variables in a clone class have the same type.
  \item \textbf{Method references}: Only if the return value of referenced method match (or are not used).
\end{itemize}
Often when allowing such variance, tradeoffs come into play. For instance, variance in literals may require the introduction of a parameter to an extracted method if the ``Extract Method'' refactoring method is used, increasing the required effort to comprehend the code.

\subsection{Gapped clones} \label{sec:t3r}
%Explain type 3, why it is not always refactorable, solution
Sometimes, when fragments are duplicated, a statement in inserted or changed severely for the code to fit its new context. When dealing with such a situation, there are several opportunities to refactor so-called ``gapped clones''. ``Gapped clones'' are two clone instances separated by a ``gap'' of non-cloned statement(s). We define the following methods to refactor such clones:
\begin{itemize}
  \item We wrap the difference in statements in a conditionally executed block, one path for each different (group of) statement(s).
  \item We use a lambda function to pass the difference in statements from each location of the clone.
\end{itemize}
Again, a tradeoff is at play, as these solutions increase the complexity in favor of removing a clone.

\section{CloneRefactor}
% NEED TO EXPLAIN WHY DO CURRENT DETECTION TOOLS NOT SUFFICE
% The tool: Detect Clones, Map Context, Refactor.
To automate the process of refactoring clones, we propose a tool named CloneRefactor. This tool goes through a 3-step process in order to refactor clones. This process is displayed in figure \ref{fig:clonerefactorflow}.
\begin{figure}[H]
  \includegraphics[width=1\columnwidth]{img/flow}
  \caption{Simple flow diagram of CloneRefactor.}
  \label{fig:clonerefactorflow}
\end{figure}
In this section, we explain each of these steps.


\subsection{Clone Detection}
% Detecting refactorable clones, (clone graph?? do I want to explain my exact methods?)
We use an AST-based method to detect clones. Clones are detected on a statement level: only full statements are considered as clones. In this process, we limit the variability between indicated expressions (see Sec.~\ref{sec:t2r}) by a threshold. This threshold is the percentage of different expressions against the total number of expressions in the source code:
\begin{equation}\label{eq:type2r}
\text{Variability}=\frac{\text{Different expressions}}{\text{Total expressions}}*100
\end{equation}

After all clones have been detected, CloneRefactor determines whether clone classes can be merged into gapped clones (see Sec.~\ref{sec:t3r}). The maximum size of the gap is limited by a threshold. This threshold is the percentage of (not-cloned) statements in the gap against the sum of statements in both clones surrounding it. Unlike the expression variability threshold, this threshold can exceed 100\%:
\begin{equation}\label{eq:type3r}
\text{Gap Size}=\frac{\text{Statements in gap}}{\text{Statements in clones}}*100
\end{equation}

\subsection{Context Mapping}
After clones are detected, we map the context of these clones. We have identifier three properties of clones as their context: relation, location and contents. We identify categories for each of these properties, to get a detailed insight in the context of clones.

\subsubsection{Relation}
% The rationale for our categories regarding clone relations.
Clone instances in a clone class can have a relation with each other through inheritance. This relation has a big impact on how the clone should be refactored \cite{fontana2015duplicated}. We define the following categories to map the relation between clone instances in a clone class. These categories do not map external classes (classes outside the project, for instance belonging to a library) unless explicitly stated:
\begin{itemize}
    \item \textbf{Common Class}: All clone instances are in the same class.
    \begin{itemize}
        \item \textbf{Same Method}: All clone instances are in the same method.
        \item \textbf{Same Class}: All clone instances are in the same class.
    \end{itemize}
    \item \textbf{Common Hierarchy}: All clone instances are in the same inheritance hierarchy.
    \begin{itemize}
        \item \textbf{Superclass}: Clone instances reside in a class or its parent class.
        \item \textbf{Sibling Class}: All clone instances reside in classes with the same parent class.
        \item \textbf{Ancestor Class}: All clone instances reside in a class, or any of its recursive parents.
        \item \textbf{First Cousin}: All clone instances reside in classes with the same grandparent class.
        \item \textbf{Same Hierarchy}: All clone instances are part of the same inheritance hierarchy.
    \end{itemize}
    \item \textbf{Common Interface}: All clone instances are in classes that have the same interface.
    \begin{itemize}
        \item \textbf{Same Direct Interface}: All clone instances are in a class that have the same interface.
        \item \textbf{Same Class}: All clone instances are in an inheritance hierarchy that contains the same interface.
    \end{itemize}
    \item \textbf{Unrelated}: All clone instances are in classes that have the same interface.
    \begin{itemize}
        \item \textbf{No Direct Superclass}: All clone instances are in classes that have the Object class as parent.
        \item \textbf{No Indirect Superclass}: All clone instances are in a hierarchy that contains a class that has the Object class as parent.
        \item \textbf{External Superclass}: All clone instances are in classes the same external class as parent.
        \item \textbf{Indirect External Ancestor}: All clone instances are in a hierarchy that contains a class that has an external class as parent.
    \end{itemize}
\end{itemize}
Based on these relations, we determine where to place the cloned code when refactored. The code of clones that have a \textit{Common Class} relation can be refactored by placing the cloned code in this same class. The code of clones with a \textit{Common Hierarchy} relation can be placed in the intersecting class in the hierarchy (the class all clone instances have in common as an ancestor). The code of clones with a \textit{Common Interface} relation can be placed in the intersecting interface, but in the process has to become part of the classes' public contract. The code of clones that are \textit{Unrelated} can be placed in a newly created place: either a utility class, a new superclass abstraction or an interface.

\subsubsection{Location}
The rationale for our categories regarding clone locations.

\subsubsection{Contents}
The rationale for our categories regarding clone contents.

\subsection{Refactoring}
\subsubsection{Extract Method}
Show my categories to show what clones can be dealt with by method extraction.

\subsubsection{AST Transformation}
Explain what AST transformations I do to apply the refactorings.

\section{Results}

\subsection{Clone context}
How many clones are there in certain contexts? Experiments for relation, location and context.

\subsection{Clone refactorability}
To what extent can found clones be refactored through method extraction, without requiring additional transformations.

\subsection{Thresholds}
I think the ultimate goal with this thesis is to do experiments with different clone thresholds. Which thresholds give clones that we should refactor? For this, we will measure the maintainability of the refactored source code over different thresholds. These thresholds range from minimum clone size, variability and gap size.

\section{Discussion}
\subsection{Clone Definitions}

\subsection{CloneRefactor}

\subsection{Experimental setup}

\section{Conclusion}

\section*{Acknowledgment}
We would like to thank the Software Improvement Group for their continuous support in this project. In particular, we would like to thank Xander Schrijen for his invaluable input in this research. Furthermore, we would like to thank Sander Meester for his proofreading efforts and feedback.

\section*{References}


\end{document}
