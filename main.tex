\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}     % for proper word breaking at line ends
\usepackage[a4paper, total={170mm,250mm}]{geometry}
                                % for page size and margin settings
\usepackage{graphicx}           % for images
\usepackage{amsmath,amssymb}    % for better equations
\usepackage{amsthm}             % for better theorem styles
\usepackage{mathtools}          % for greek math symbol formatting
\usepackage{enumitem}           % for control of 'enumerate' numbering
\usepackage{listings}           % for control of 'itemize' spacing
\usepackage{todonotes}          % for clear TODO notes
\usepackage{hyperref}           % page numbers and '\ref's become clickable
\usepackage{titlesec}
\usepackage{csquotes}

\def\thesistitle{Automatic Refactoring of Code Clones in Object-Oriented Programming Languages}
\def\thesissubtitle{Improving a systems maintainability with the push of a button}
\def\thesisauthorfirst{Simon}
\def\thesisauthorsecond{Baars}
\def\thesissupervisorfirst{dr. Ana}
\def\thesissupervisorsecond{Oprescu}
\def\thesissecondreaderfirst{dr. Xander}
\def\thesissecondreadersecond{Schrijen}
\def\thesisdate{\today}

%% FOR PDF METADATA
\title{\thesistitle}
\author{\thesisauthorfirst\space\thesisauthorsecond}
\date{\thesisdate}

%% THEOREM STYLES
\newtheorem{theorem}{Stelling}[section]
\newtheorem{corollary}{Gevolg}[theorem]
\newtheorem{Lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Propositie}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definitie}

\theoremstyle{remark}
\newtheorem*{remark}{Opmerking}


%% MATH OPERATORS
\DeclareMathOperator{\supersine}{supersin}
\DeclareMathOperator{\supercosine}{supercos}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\begin{titlepage}
	\thispagestyle{empty}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	%\textsc{\University of Amsterdam}\\[.7cm]
	\includegraphics[width=100mm]{img/logoUvA_en.pdf}\\[.5cm]
	\textsc{Faculty of Science}\\[0.5cm]

	\HRule \\[0.4cm]
	{ \huge \bfseries \thesistitle}\\[0.1cm]
	\textsc{\thesissubtitle}\\
	\HRule \\[.5cm]
	\textsc{\large Master Thesis Software Engineering}\\[2cm]

	\begin{minipage}{0.4\textwidth}
	\begin{flushleft} \large
	\emph{Author:}\\
	\thesisauthorfirst\space \thesisauthorsecond \\[1em]
	\emph{Student Number:}\\
	12072931 \\[1em]
	\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
	\begin{flushright} \large
	\emph{Academic Supervisor:} \\
	\thesissupervisorfirst\space \thesissupervisorsecond \\[1em]
	\emph{Company Supervisor:} \\
	\thesissecondreaderfirst\space \thesissecondreadersecond \\[1em]
	\emph{Company:} \\
	Software Improvement Group\space \textsc{\thesissecondreadersecond}
	\end{flushright}
	\end{minipage}\\[4cm]
	\vfill
	{\large \thesisdate}\\
	\clearpage
\end{titlepage}

\tableofcontents

\newpage
\chapter{Abstract}
\todo[inline,color=blue!10]{This should be done when most of the rest of the document is finished.}

\newpage
\chapter{Introduction}
Refactoring is used to improve quality related attributes of a codebase (maintainability, performance, etc.) without changing the functionality. There are many methods that have been introduced to help with the process of refactoring \cite{fowler2018refactoring, wake2004refactoring}. However, most of these methods still require manual assessment of where and when to apply them. Because of this, refactoring takes up a signification portion of the development process \cite{lientz1978characteristics, mens2004survey}, or does not happen at all \cite{mens2003refactoring}. Refactoring mostly requires some domain knowledge to do it right, but there are also refactoring opportunities that are rather trivial and repetitive to execute. In this thesis, we take a look at the challenges and opportunities in automatically refactoring duplicated code, also known as ``code clones''. The main goal is to improve maintainability of the refactored code.

There are several models which describe ways to measure maintainability. None of these are sufficient to make a full assessment of the maintainability of a software project, but they strive to give a good indication. For this thesis, we will make use of the \textit{SIG maintainability model} \cite{heitlager2007practical}, as it is based on a lot of experience in the field of software quality assessment. This maintainability model is independent of programming language. For this thesis we will lay the main focus on the Java programming language as refactoring opportunities do feature paradigm and programming language dependent aspects \cite{choi2011extracting}. However, most practises used in this thesis will also be applicable with other object oriented languages, like C\#.

Improving the maintainability metrics does not automatically lead to a better maintainable codebase \cite{fenton1999software}. For instance, in general, a bigger codebase (in volume) is harder to maintain. However, refactoring a big method into smaller methods can definitely improve the maintainability of the codebase (but still increase the volume metric). Because of this, it is important that refactorings focus on the resolution of harmful anti-patterns \cite{kapser2006cloning} rather than just the improvement of the metrics. This will be one of our main focus points in this thesis.

For this research, we will focus on formalizing the refactoring process of dealing with duplication in code. To validate this approach, we will validate the refactored results with domain experts. Apart from that, we will show the improvement of the metrics over various open source and industrial projects. Likewise, we will perform an estimation of the development costs that are saved by using the proposed solution.

\section{Research questions}
Code clones can appear anywhere in the code. Whether a code clone has to be refactored, and how it has to be refactored, is dependent on where it exists in the code (it's context). There are many different contexts in which code clones can occur (in a method, a complete class, in an enumeration, global variables, etc.). Because of this, we first must collect some information regarding in what contexts code clones exist. To do this, we will analyze a set of Java projects for their clones, and generalize their contexts. To come to this information, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 1:}\\How can we group and rank clones based on their harmfulness?
\end{displayquote}
As a result from this research question, we expect a catalog of the different contexts in which clones occur, ordered on the amount of times they occur. On basis of this catalog, we have prioritized the further analysis of the clones. This analysis is to determine a suitable refactoring for the clone type that has been found at the design level. For this, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 2:}\\To what extend can we suggest refactorings of clones at the design level?
\end{displayquote}
As a result, we expect to have proposed refactorings for the most harmful clone patterns. On basis of these design level refactorings we will build a model, which we will proof using Java, that applies the refactorings to corresponding methods. For building this model, we have formulated the following research question:
\begin{displayquote}
\textbf{Research Question 3:}\\To what extend can we automatically refactor clones?
\end{displayquote}
As a result from this research question, we expect to have a model to be able to refactor the highest priority clones.

\section{Scope}
In this research we will look into code clones from a refactoring viewpoint. There are several methods that detect code clones using a similarity score to match pieces of code. This similarity is often based on the amount of tokens that match between two pieces of code. The problem with similarity based clones is that it is hard to assess the impact of merging clones that have different tokens, but what exactly this token is is unknown. Because of this, we will not focus on similarity based clone detection techniques, but rather on exact matches and predefined differences.

It is very disputable whether unit tests apply to the same maintainability metrics that applies to the functional code. Because of that, for this research, unit tests are not taken into scope. The findings of this research may be applicable to those classes, but we will not argue the validity. %TODO: There was some research about this.


\newpage
\bibliographystyle{plain}
\bibliography{references.bib}

\end{document}
