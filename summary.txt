Improving Software Maintainability through Automated Refactoring of Code Clones - Summary
To be able to deliver high-quality software without major delays, it is important to control the maintainability of software. Low maintainability means that developers spend too much time on maintaining and fixing old code. Research shows that maintaining source code takes at least twice as long when maintainability is measured as below average, compared to when maintainability is above average. Lack of maintainability is to a large extent caused by simple issues that occur over and over again. Consequently, the most efficient and effective way to improve maintainability is to address these simple issues.

One of the most harmful of these issues is duplication. Duplication in source code, also called “code clones”, is the result of a developer reusing code by copying it to another place in the codebase. The often more desired alternative is to, instead of copying code, introduce abstractions to call the same code from different places. Failing to do so needlessly increases the size of the system (up to 25% overhead). It also makes the system more error-prone, because making a change in a cloned code fragment may have to be applied to the other instances as well. Failing to do so can result in unintended behavior.

To solve such duplication issues several refactoring techniques can be used. Refactoring is the process of restructuring code to improve its quality attributes, without changing its functionality. Manual refactoring efforts to reduce duplication take time, require expertise and are prone to cause bugs. To mitigate these issues, we look into to what extent duplication can automatically be refactored.

We first look into how to define clones such that they can be refactored. We look into existing clone type definitions, which argue about the variance that is allowed between code fragments to still consider them clones. The problem concerning our goals is that these definitions cannot be automatically refactored. We propose new clone type definitions that allow for automated refactoring and propose a method with which to detect clones by these definitions.

To determine what refactoring method to use to refactor clones, we consider their context. We define the context of clones as their relation, location and contents attributes. The relation argues about how each similar fragment in a clone is related to one another, which is important to determine where to place the merged code fragment. The location argues about in what type of place the clone is located in the code: this is used to determine the refactorability of the clone (not every location can be refactored). The contents argue about what code the clone spans: based on this, different refactoring techniques may be required.

We then perform statistical measurements on these context categories, to understand which refactoring methods can be used to refactor most clones. We find that most clones can be refactored by moving common code to a new method and placing that method in a location that is accessible by all places the duplicated code was used, then replacing each of these fragments by a call to the new method. This technique is called “Extract Method”. We apply this technique to automatically refactor clones in a large corpus of open-source Java projects and use it to automatically refactor 28% of the present duplication.

We then look at which characteristics of the refactored clones have the biggest impact on the maintainability of the system. We find that the size of the clone, measured in number of tokens (a token is the smallest element of a program that is meaningful to the compiler), has the biggest impact on the maintainability of the system. A second factor with a large impact is the amount of data used in both code fragments that are declared outside the scope of the fragment. The latter is currently not used to determine whether a clone should be refactored, however, our results show that it is relevant to be considered.

Our research delivers the first steps towards fully automated refactoring of code clones. It also provides additional support towards what factors should be taken into account to determine whether a clone should be refactored. Furthermore, we define important factors to be taken into account to determine whether duplication with certain characteristics would improve the codebase when refactored.